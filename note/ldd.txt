system call - exception <- User Mode
interrupt context & 
process context: ioclt, netlink
softirqs va tasklet
linux kernel - kernel thread
workqueue - defered work -> worker threads -> events/n (number of CPU)
Softirqs: Ít thực hiện tuần tự nhất.
Tasklet: Giao diện sử dụng đơn giản, khả năng threaded ít hơn softirqs
Work Queue: Giao diện sử dụng đơn giản nhất, ngữ cảnh tiến trình
kernel preemption - (preemptive kernel & non - preemptive kernel) - planned process switch - force process switch
Đồng bộ
critical region - race condition
Nguồn gây mất đồng bộ:
 - Ngắt - interrupts
 - softirps & tasklet
 - kernel preemption
 - sleeping
 - hệ thống nhiều cpu
Khi nào cần đồng bộ:
    Dữ liệu có phải là dữ liệu toàn cục – global không, có xảy ra trường hợp nhiều luồng thực thi xử lý dữ liệu hay không?
    Dữ liệu có phải được dùng chung giữa ngữ cảnh tiến trình và ngữ cảnh ngắt không, có được dùng chung giữa các hàm xử lý ngắt không?
    Nếu một tiến trình bị forced process swich (buộc chuyển tiến trình) do kernel preemption trong khi đang truy cập dữ liệu, thì liệu tiến trình mới có sử dụng chung dữ liệu đó không?
    Một đoạn mã nguồn, hay một hàm, có thể được thực ở hai CPU cùng lúc không?
    …..
Chú ý:

Chúng ta cần đồng bộ dữ liệu, chứ không phải mã nguồn. Vì vậy các phương pháp đồng bộ sẽ dùng để bảo vệ dữ liệu, chứ không phải mã nguồn.

Per-CPU Variables: dữ liệu riêng cho từng CPU
tĩnh -> DEFINE_PER_CPU(type, name)
động -> __alloc_percpu
per_cpu & per_cpu_ptr

atomic operations:atomic_t
spin locks: tương tự khóa cửa wc - spinlock_t -> error deadlock
trong hàm spin_lock() thì hàm preempt_disable sẽ được gọi
Read/Write spin locks: rwlock_t có gán nhãn R W (DEFINE_RWLOCK)
Semaphores: sleeping lock - ngủ trong khi chờ bằng cách ghi danh - rw_semaphores
local interrupt disabling

deferable functions disabling & enabling
dead lock

Read-copy update (RCU) - lock-free - con trỏ được cấp phát mới sử dụng được RCU
- kernel control path không được sleep bên trong vùng khẩn cấp được bảo vệ bởi RCU

